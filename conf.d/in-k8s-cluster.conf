server {
    listen 80 default_server;
    server_name localhost;
    include /etc/nginx/conf.d/openapi/*.conf;
    include /etc/nginx/conf.d/chain/evm/*.conf;
    include /etc/nginx/conf.d/chain/*.conf;

    access_log /etc/nginx/logs/v5-rpc-proxy-access.log rpc-proxy;
    error_log /etc/nginx/logs/v5-rpc-proxy-error.log error;

#    allow 10.100.0.0/16;   # Service 网段
#    allow 192.168.0.0/16; # Pod 网段
#    deny all;            # 拒绝其他所有来源

location /nginx-ui/ {
    proxy_pass http://localhost:9000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    rewrite ^/nginx-ui/(.*)$ /$1 break;
}

    location /unisat/ {
        access_log /etc/nginx/logs/unisat-access.log rpc-proxy;
        error_log /etc/nginx/logs/unisat-error.log error;

        set $proxy_host "open-api.unisat.io";
        proxy_pass https://open-api.unisat.io/;

        proxy_set_header Host open-api.unisat.io;
        proxy_set_header accept-encoding "identity";
        set_by_lua_block $unisat_api_key {
            return os.getenv("UNISAT_API_KEY") or ""
        }
        proxy_set_header Authorization "Bearer $unisat_api_key";
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_ssl_server_name on;
        proxy_redirect off;
    }

    location ~ /nownodes/(?<node_type>[^/]+)/?(?<path>/?.*)?$ {
        access_log /etc/nginx/logs/nownodes-access.log rpc-proxy;
        error_log /etc/nginx/logs/nownodes-error.log error;
        
        set_by_lua_block $nownodes_api_key {
            return os.getenv("NOWNODES_API_KEY_ROUTE") or ""
        }
        
        rewrite ^/nownodes/[^/]+/?(.*)$ /$1 break;
        set $proxy_host "$node_type.nownodes.io";
        
        proxy_pass https://$node_type.nownodes.io/$path$is_args$args;
        proxy_set_header api-key $nownodes_api_key;
        proxy_set_header accept-encoding "identity";
        proxy_set_header Host $node_type.nownodes.io;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_ssl_server_name on;
        proxy_redirect off;
    }

    location /blockberry/ {
        access_log /etc/nginx/logs/blockberry-access.log rpc-proxy;
        error_log /etc/nginx/logs/blockberry-error.log error;

        proxy_pass https://api.blockberry.one/;
        set_by_lua_block $blockberry_api_key_route {
            return os.getenv("BLOCKBERRY_API_KEY_ROUTE") or ""
        }
        proxy_set_header x-api-key "$blockberry_api_key_route";
        proxy_set_header accept-encoding "identity";
        proxy_set_header Host api.blockberry.one;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_ssl_server_name on;
        proxy_redirect off;
    }

    location /clear_shared_dict {
        content_by_lua_block {
            local dict = ngx.shared.backends_health
            dict:flush_all()
            ngx.say("Shared dictionary flushed.")
        }
    }

    set $request_headers '';
    set $response_body '';
    set $response_headers '';
    set $proxy_pass_url '';

    access_by_lua_block {
        ngx.ctx.proxy_host = ngx.var.proxy_host or "-"

        local cjson = require "cjson"
        -- 捕获请求头
        local h = ngx.req.get_headers()
        ngx.var.request_headers = cjson.encode(h)
        -- 捕获请求体
        local function capture_request_body()
            local body = ngx.req.get_body_data()
            if body then
                return body
            else
                local body_file = ngx.req.get_body_file()
                if body_file then
                    local f = io.open(body_file, "r")
                    if f then
                        body = f:read("*all")
                        f:close()
                        return body
                    end
                end
            end
            return ""
        end
        ngx.ctx.request_body = capture_request_body()
    }

    body_filter_by_lua_block {
        local chunk = ngx.arg[1]
        local eof = ngx.arg[2]

        if not ngx.ctx.response_body then
            ngx.ctx.response_body = ""
        end

        if chunk then
            ngx.ctx.response_body = ngx.ctx.response_body .. chunk
        end

        if eof then
            ngx.var.response_body = ngx.ctx.response_body
        end
    }

    header_filter_by_lua_block {
        ngx.header["transfer-encoding"] = nil
        ngx.header["connection"] = nil
    }

log_by_lua_block {
    local proxy_pass_url = ngx.ctx.proxy_pass_url or "-"
    ngx.var.proxy_pass_url = proxy_pass_url

    -- 捕获响应头
    local headers = ngx.resp.get_headers()
    local cjson = require "cjson"

    -- 初始化变量，防止为nil
    local header_log = ""
    if headers then
        header_log = cjson.encode(headers)
    end

    -- 将响应头记录到变量
    ngx.var.response_headers = header_log or "-"

    -- 记录到日志
    if header_log ~= "" then
        ngx.log(ngx.ERR, "Response Headers: ", header_log)
    else
        ngx.log(ngx.ERR, "No Response Headers available.")
    end

    -- 初始化响应体，防止为nil
    ngx.var.response_body = ngx.ctx.response_body or ""
}

    location /health {
        default_type text/plain;

        content_by_lua_block {
            local healthcheck = require("resty.upstream.healthcheck")
            local status_info = healthcheck.status_page()
            ngx.say(status_info)
        }
    }

    location /backends-status {
        chunked_transfer_encoding off;
        content_by_lua_block {
            local show_status = require "rpc-proxy.backends-status"
            show_status()
        }
    }
}
