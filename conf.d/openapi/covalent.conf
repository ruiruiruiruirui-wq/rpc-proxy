    location /covalent/ {
        access_log /etc/nginx/logs/covalent-access.log rpc-proxy;
        error_log /etc/nginx/logs/covalent-error.log error;

        content_by_lua_block {
            local http = require "resty.http"
            local cjson = require "cjson"
            
            -- 从环境变量获取 API key
            local api_key = os.getenv("API_COVALENTHQ_COM_KEY")
            if not api_key then
                ngx.log(ngx.ERR, "API_COVALENTHQ_COM_KEY environment variable not set")
                ngx.status = 500
                ngx.say('{"error": "API key not configured"}')
                return
            end
            
            -- 构建上游 URL
            local uri = ngx.var.uri
            local args = ngx.var.args
            local path = string.gsub(uri, "^/covalent/", "/")
            local upstream_url = "https://api.covalenthq.com" .. path
            if args then
                upstream_url = upstream_url .. "?" .. args
            end
            
            -- 创建 HTTP 客户端
            local httpc = http.new()
            httpc:set_timeout(30000)  -- 30 秒超时
            
            -- 准备请求头
            local headers = {}
            local req_headers = ngx.req.get_headers()
            for k, v in pairs(req_headers) do
                if k ~= "host" and k ~= "connection" and k ~= "authorization" then
                    headers[k] = v
                end
            end
            headers["Host"] = "api.covalenthq.com"
            headers["Authorization"] = "Bearer " .. api_key
            headers["accept-encoding"] = "identity"
            
            -- 获取请求体
            ngx.req.read_body()
            local body = ngx.req.get_body_data()
            
            -- 发送请求
            local res, err = httpc:request_uri(upstream_url, {
                method = ngx.var.request_method,
                body = body,
                headers = headers,
                ssl_verify = false,
                keepalive_timeout = 60000,
                keepalive_pool = 10
            })
            
            if not res then
                ngx.log(ngx.ERR, "failed to request upstream: ", err)
                ngx.status = 502
                ngx.say('{"error": "upstream request failed"}')
                return
            end
            
            -- 设置响应状态和头
            ngx.status = res.status
            for k, v in pairs(res.headers) do
                if k ~= "connection" and k ~= "transfer-encoding" then
                    ngx.header[k] = v
                end
            end
            
            -- 输出响应体
            ngx.say(res.body)
        }
    }
