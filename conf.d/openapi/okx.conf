    location /okx/ {
        access_log /etc/nginx/logs/okx-access.log rpc-proxy;
        error_log /etc/nginx/logs/okx-error.log error;

        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            local secretKey = os.getenv("OKX_SECRET_KEY")
            local accessProject = os.getenv("OKX_ACCESS_PROJECT")
            local accessKey = os.getenv("OKX_ACCESS_KEY")
            local accessPassphrase = os.getenv("OKX_ACCESS_PASSPHRASE")

            if not (secretKey and accessProject and accessKey and accessPassphrase) then
                ngx.log(ngx.ERR, "Missing required OKX credentials")
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end

            local uri = ngx.var.uri
            local request_uri = ngx.var.request_uri
            ngx.log(ngx.ERR, "Original URI (ngx.var.uri): ", uri)
            ngx.log(ngx.ERR, "Request URI (ngx.var.request_uri): ", request_uri)
            local path = string.gsub(uri, "^/okx/", "/")
            ngx.log(ngx.ERR, "After gsub path: ", path)
            local method = ngx.req.get_method()
            
            local timestamp = os.date("!%Y-%m-%dT%H:%M:%S.000Z")
            
            local preHash = ""
            local body
            
            if method == "POST" or method == "PUT" or method == "PATCH" then
                ngx.req.read_body()
                body = ngx.req.get_body_data()
                if body then
                    preHash = body
                end
            elseif method == "GET" then
                local args = ngx.req.get_uri_args()
                if args and next(args) then
                    local query_parts = {}
                    for k, v in pairs(args) do
                        if type(v) == "table" then
                            for _, val in ipairs(v) do
                                table.insert(query_parts, k .. "=" .. tostring(val))
                            end
                        else
                            table.insert(query_parts, k .. "=" .. tostring(v))
                        end
                    end
                    table.sort(query_parts)
                    preHash = "?" .. table.concat(query_parts, "&")
                end
            end
            
            local message = timestamp .. method:upper() .. path .. preHash
            ngx.log(ngx.ERR, "Message before signing: ", message)
            

            -- 使用 openssl 命令计算 HMAC-SHA256
            local function calculate_hmac_sha256(key, message)
                -- 转义特殊字符
                local escaped_message = message:gsub("'", "'\"'\"'"):gsub("\\", "\\\\")
                local escaped_key = key:gsub("'", "'\"'\"'"):gsub("\\", "\\\\")
                
                local cmd = string.format("echo -n '%s' | openssl dgst -sha256 -hmac '%s' -binary 2>/dev/null | base64", escaped_message, escaped_key)
                ngx.log(ngx.ERR, "HMAC command: ", cmd)
                local handle = io.popen(cmd)
                if handle then
                    local result = handle:read("*a")
                    handle:close()
                    -- 移除可能的换行符
                    result = result:gsub("%s+", "")
                    ngx.log(ngx.ERR, "HMAC result: ", result)
                    return result
                end
                return nil
            end
            
            local signature_base64 = calculate_hmac_sha256(secretKey, message)
            
            if not signature_base64 then
                ngx.log(ngx.ERR, "Failed to calculate HMAC-SHA256 signature")
                return ngx.exit(500)
            end
            
            -- 调试日志
            ngx.log(ngx.ERR, "=== OKX DEBUG ===")
            ngx.log(ngx.ERR, "Timestamp: ", timestamp)
            ngx.log(ngx.ERR, "Method: ", method:upper())
            ngx.log(ngx.ERR, "Path: ", path)
            ngx.log(ngx.ERR, "PreHash: ", preHash)
            ngx.log(ngx.ERR, "Message: ", message)
            ngx.log(ngx.ERR, "Signature: ", signature_base64)
            ngx.log(ngx.ERR, "==================")
            
            local headers = {
                ["Host"] = "www.okx.com",
                ["OK-ACCESS-PROJECT"] = accessProject,
                ["OK-ACCESS-KEY"] = accessKey,
                ["OK-ACCESS-PASSPHRASE"] = accessPassphrase,
                ["OK-ACCESS-SIGN"] = signature_base64,
                ["OK-ACCESS-TIMESTAMP"] = timestamp,
                ["accept-encoding"] = "identity",
                ["X-Real-IP"] = ngx.var.remote_addr,
                ["X-Forwarded-For"] = ngx.var.http_x_forwarded_for or ngx.var.remote_addr
            }
            
            if ngx.var.http_content_type then
                headers["Content-Type"] = ngx.var.http_content_type
            end
            
            local final_url = "https://www.okx.com" .. path
            -- 只有 GET 请求才将 preHash 附加到 URL
            if method == "GET" and preHash and preHash ~= "" then
                final_url = final_url .. preHash
            end
            ngx.log(ngx.ERR, "Final request URL: ", final_url)
            local res, err = httpc:request_uri(final_url, {
                method = method,
                headers = headers,
                body = body,
                ssl_verify = false
            })
            
            if not res then
                ngx.log(ngx.ERR, "Failed to request OKX API: ", err)
                return ngx.exit(500)
            end
            
            ngx.status = res.status
            
            for k, v in pairs(res.headers) do
                if k ~= "transfer-encoding" then
                    ngx.header[k] = v
                end
            end
            
            ngx.say(res.body)
        }

        # proxy_pass https://www.okx.com/;
        # proxy_set_header Host www.okx.com;
        # proxy_set_header OK-ACCESS-PROJECT "44ffcb0363762f281ded91662b182468";
        # proxy_set_header OK-ACCESS-KEY "2338f3d0-2df2-4da6-9419-5e153c9bd6c3";
        # proxy_set_header OK-ACCESS-PASSPHRASE "gqg0HFG1ztu!tuz0mca";

        # proxy_set_header accept-encoding "identity";
        # proxy_set_header X-Real-IP $remote_addr;
        # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # proxy_ssl_server_name on;
        # proxy_redirect off;
    }
