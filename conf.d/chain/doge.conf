location /doge/ {
    access_log /etc/nginx/logs/doge-access.log rpc-proxy;
    error_log /etc/nginx/logs/doge-error.log;
    content_by_lua_block {
        local http = require "resty.http"
        local httpc = http.new()
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        -- 从环境变量获取 API key
        local api_key = os.getenv("GO_GETBLOCK_IO_KEY")
        if not api_key then
            ngx.log(ngx.ERR, "GO_GETBLOCK_IO_KEY environment variable not set")
            ngx.status = 500
            ngx.say('{"error": "API key not configured"}')
            return
        end

        -- 定位 '/doge/' 并从其后开始截取 URI
        local base_path = "/doge/"
        local start_pos = ngx.var.request_uri:find(base_path)
        if not start_pos then
            ngx.log(ngx.ERR, "URI does not contain '/doge/'")
            return ngx.exit(500)
        end

        -- 构建新的目标 URI
        local target_uri = "https://go.getblock.io/" .. api_key .. "/" .. ngx.var.request_uri:sub(start_pos + #base_path)

        -- 发送请求到目标服务器
        local res, err = httpc:request_uri(target_uri, {
            method = ngx.var.request_method,  -- 使用与客户端相同的请求方法
            body = body_data,
            headers = {
                ["Host"] = "go.getblock.io",
                ["Content-Type"] = ngx.var.content_type,
                -- 如果需要其他头部，可以在这里添加
            },
            ssl_verify = false  -- 在生产环境中应启用SSL验证
        })

        if not res then
            ngx.log(ngx.ERR, "request failed: ", err)
            return ngx.exit(500)
        end

        -- 将目标服务器的响应头发送给客户端
        for k, v in pairs(res.headers) do
            ngx.header[k] = v
        end

        -- 设置响应状态码
        ngx.status = res.status

        -- 发送响应体到客户端
        ngx.say(res.body)
        ngx.exit(ngx.HTTP_OK)
    }
}
