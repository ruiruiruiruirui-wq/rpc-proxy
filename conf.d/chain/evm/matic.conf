    location /matic/ {
        access_log /etc/nginx/logs/matic-access.log rpc-proxy;
        error_log /etc/nginx/logs/matic-error.log;
    
        content_by_lua_block {
            local ok, err = pcall(function()
                local health_checker = require "rpc-proxy.rpc-check"
                local backend = health_checker.get_backend("matic")
                if not backend or not backend.url then
                    ngx.log(ngx.ERR, "[proxy] no backend found for matic")
                    return ngx.exit(502)
                end

                local http = require "resty.http"
                local httpc = http.new()
                httpc:set_timeout(50000)

                local path = ngx.var.uri
                local prefix = "/matic/"
                local index = path:find(prefix, 1, true)
                local subpath = ""
                if index then
                    subpath = path:sub(index + #prefix)
                end

                local target_uri = backend.url
                if subpath ~= "" then
                    target_uri = target_uri .. "/" .. subpath
                end

                local query = ngx.var.args
                if query then
                    target_uri = target_uri .. "?" .. query
                end

                ngx.req.read_body()
                local body_data = ngx.req.get_body_data()
                local content_type = ngx.var.content_type or "application/json"

                ngx.log(ngx.ERR, "[proxy] forwarding to ", target_uri)

                local res, err = httpc:request_uri(target_uri, {
                    method = ngx.var.request_method,
                    body = body_data,
                    headers = {
                        ["Host"] = backend.host or nil,
                        ["Content-Type"] = content_type,
                        ["X-Real-IP"] = ngx.var.remote_addr,
                        ["X-Forwarded-For"] = ngx.var.remote_addr
                    },
                    ssl_verify = false
                })

                if not res then
                    ngx.log(ngx.ERR, "[proxy] request to backend failed: ", err or "unknown")
                    return ngx.exit(502)
                end

                for k, v in pairs(res.headers) do
                    if k:lower() ~= "transfer-encoding" and k:lower() ~= "connection" then
                        ngx.header[k] = v
                    end
                end

                ngx.status = res.status
                ngx.say(res.body or "")
                ngx.ctx.proxy_pass_url = backend.host

                httpc:set_keepalive(10000, 10)
            end)

            if not ok then
                ngx.log(ngx.ERR, "[proxy] caught error: ", err)
                ngx.status = 500
                ngx.say('{"error":"internal server error"}')
                return ngx.exit(500)
            end
        }

        proxy_set_header Accept-Encoding "identity";
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_ssl_server_name on;
        proxy_redirect off;
    
    }

