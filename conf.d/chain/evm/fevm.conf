location /fevm/ {
    access_log /etc/nginx/logs/fevm-access.log rpc-proxy;
    error_log /etc/nginx/logs/fevm-error.log;

content_by_lua_block {
    local health_checker = require "rpc-proxy.rpc-check"
    local backend = health_checker.get_backend("fevm")

    local http = require "resty.http"
    local httpc = http.new()
    httpc:set_timeout(50000)  -- 设置超时时间为5000毫秒

    -- 解析原始请求URI，动态地从中截取 "/fevm/" 之后的部分
            local path = ngx.var.uri
            local prefix = "/fevm/"
            local index = path:find(prefix, 1, true)
            local subpath = ""

            if index then
                subpath = path:sub(index + #prefix)
            end

    -- 构造新的目标URL
    local target_uri = backend.url
    if subpath ~= "" then
        target_uri = target_uri .. "/" .. subpath
    end

    local query = ngx.var.args
    if query then
        target_uri = target_uri .. "?" .. query
    end

    ngx.req.read_body()  -- 读取请求体数据
    local body_data = ngx.req.get_body_data()

    local res, err = httpc:request_uri(target_uri, {
        method = ngx.var.request_method,
        body = body_data,
        headers = {
            ["Host"] = backend.host,
            ["Content-Type"] = ngx.var.content_type,  -- 确保内容类型正确传递
            ["X-Forwarded-For"] = ngx.var.remote_addr
        },
        ssl_verify = false
    })

    if not res then
        ngx.log(ngx.ERR, "Request to backend " .. backend.host .. " failed: ", err)
        return ngx.exit(500)
    end

    -- 将后端服务器的响应传递回客户端
    ngx.ctx.proxy_pass_url = backend.host
    for k, v in pairs(res.headers) do
        ngx.header[k] = v
    end
    ngx.status = res.status
    ngx.say(res.body)
    ngx.exit(ngx.HTTP_OK)
}

}

