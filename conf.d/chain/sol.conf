    location /sol/ {
        access_log /etc/nginx/logs/sol-access.log rpc-proxy;
        error_log /etc/nginx/logs/sol-error.log;
    
        content_by_lua_block {
            -- 添加请求ID用于调试
            local request_id = ngx.var.connection .. "-" .. ngx.var.connection_requests
            ngx.log(ngx.INFO, "Processing request: " .. request_id)
            
            local health_checker = require "rpc-proxy.sol"
            local backend = health_checker.get_backend("sol")
            
            if not backend then
                ngx.log(ngx.ERR, "No available backend for sol")
                return ngx.exit(503)
            end
    
            local http = require "resty.http"
            local httpc = http.new()
            
            -- 增加超时时间
            httpc:set_timeout(600000)  -- 10分钟超时
    
            local path = ngx.var.uri
            local prefix = "/sol/"
            local index = path:find(prefix, 1, true)
            local subpath = ""

            if index then
                subpath = path:sub(index + #prefix)
            end
    
            local target_uri = backend.url
            if subpath ~= "" then
                target_uri = target_uri .. "/" .. subpath
            end
    
            local query = ngx.var.args
            if query then
                target_uri = target_uri .. "?" .. query
            end
    
            ngx.req.read_body()
            local body_data = ngx.req.get_body_data()
            
            ngx.log(ngx.INFO, "Request " .. request_id .. " to backend: " .. backend.host)
    
            -- 智能请求处理：根据请求内容调整超时时间
            local is_large_response = false
            
            -- 检查是否是可能产生大响应的请求
            if body_data then
                local cjson = require "cjson"
                local ok, request_data = pcall(cjson.decode, body_data)
                if ok and request_data then
                    -- 检查单个请求
                    if request_data.method then
                        if request_data.method == "getBlock" or 
                           request_data.method == "getBlocks" or
                           request_data.method == "getMultipleAccounts" then
                            is_large_response = true
                            ngx.log(ngx.INFO, "Request " .. request_id .. " detected large response method: " .. request_data.method)
                        end
                    end
                    
                    -- 检查批量请求
                    if type(request_data) == "table" and #request_data > 0 then
                        for _, req in ipairs(request_data) do
                            if req.method and (req.method == "getBlock" or 
                                              req.method == "getBlocks" or
                                              req.method == "getMultipleAccounts") then
                                is_large_response = true
                                ngx.log(ngx.INFO, "Request " .. request_id .. " detected large response method in batch: " .. req.method)
                                break
                            end
                        end
                    end
                end
            end
            
            -- 根据响应大小调整超时时间
            local timeout = is_large_response and 1200000 or 600000  -- 20分钟 vs 10分钟
            httpc:set_timeout(timeout)
    
            local res, err = httpc:request_uri(target_uri, {
                method = ngx.var.request_method,
                body = body_data,
                headers = {
                    ["Host"] = backend.host,
                    ["Content-Type"] = ngx.var.content_type,
                    ["X-Forwarded-For"] = ngx.var.remote_addr,
                    ["Connection"] = "keep-alive",
                    ["Accept-Encoding"] = "identity"
                },
                ssl_verify = false,
                keepalive = true,
                keepalive_timeout = 60000,
                keepalive_pool = 500
            })
    
            if not res then
                ngx.log(ngx.ERR, "Request " .. request_id .. " to backend " .. backend.host .. " failed: ", err)
                return ngx.exit(500)
            end
    
            ngx.ctx.proxy_pass_url = backend.host
            
            -- 设置响应头
            if res.headers["content-type"] then
                ngx.header["Content-Type"] = res.headers["content-type"]
            end
            
            -- 保持原始的传输编码
            if res.headers["transfer-encoding"] then
                ngx.header["Transfer-Encoding"] = res.headers["transfer-encoding"]
            elseif res.headers["content-length"] then
                ngx.header["Content-Length"] = res.headers["content-length"]
            end
            
            ngx.status = res.status
            
            -- 统一使用标准响应处理
            ngx.log(ngx.INFO, "Request " .. request_id .. " reading response body...")
            
            if res.body then
                local body_size = #res.body
                ngx.log(ngx.INFO, "Request " .. request_id .. " response size: " .. body_size .. " bytes")
            ngx.say(res.body)
            else
                ngx.log(ngx.WARN, "Request " .. request_id .. " no response body found")
            end
            
            ngx.log(ngx.INFO, "Request " .. request_id .. " completed successfully")
            ngx.exit(ngx.HTTP_OK)
        }

        # 增加缓冲区大小以处理大响应
        client_body_buffer_size 10m;
        client_max_body_size 10m;
        proxy_buffering off;
        proxy_request_buffering off;

        proxy_set_header accept-encoding "identity";
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_ssl_server_name on;
        proxy_redirect off;
    }
